# Story 2.1.4: Create Verification Server Action with Self-Verification Block

**Epic:** 2.1 Community Verification Flow  
**Story Points:** 6 (COMPLEX - Race conditions + session_id integration)  
**Sprint:** 2  
**Status:** Not Started

---

## User Story

**As a** system  
**I want** to prevent users from verifying their own reports  
**So that** verification integrity is maintained

---

## Acceptance Criteria

- [ ] Server Action: `/app/actions/createVerification.ts`
- [ ] Input validation:
  - Required: issue_id, verifier_id, photo_url, lat, lng
  - Optional: note, voice_note_url
- [ ] **Self-verification block (authenticated users):**
  - Query: `SELECT user_id FROM issues WHERE id = issue_id`
  - If `user_id = verifier_id`, reject with error: "Cannot verify your own report"
- [ ] **Session-based self-verification block (anonymous reports):**
  - Query: `SELECT session_id FROM issues WHERE id = issue_id AND user_id IS NULL`
  - Get verifier's session_id from localStorage (passed as param)
  - If `session_id = verifier_session_id`, reject: "Cannot verify your own report"
- [ ] Insert verification record into `verifications` table
- [ ] **Atomic increment with race condition prevention:**
  - Use PostgreSQL row-level locking (`FOR UPDATE`)
  - Increment `verifications_count` atomically
  - Check threshold with new count in same transaction
- [ ] **2-verification threshold check:**
  - If `verifications_count >= 2` AND `status = 'pending'`
  - Update `status = 'verified'`
  - Increment `reporter.verified_reports_count`
- [ ] **Prevent duplicate verifications:** One user can only verify an issue once
  - Add unique constraint: `UNIQUE(issue_id, verifier_id)`
  - Show friendly error: "You already verified this issue"
- [ ] Transaction rollback on any error (atomic operation)
- [ ] Error handling:
  - Self-verification blocked: Return `{ success: false, error: 'self_verification' }`
  - Duplicate verification: Return `{ success: false, error: 'already_verified' }`
  - Database error: Log error + return generic message
- [ ] Success response: `{ success: true, verification_id: uuid, new_status: string }`

---

## Technical Implementation

### Server Action Structure

```typescript
// app/actions/createVerification.ts
'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';

interface CreateVerificationInput {
  issue_id: string;
  verifier_id: string;
  verifier_session_id: string | null; // From localStorage
  photo_url: string;
  note?: string;
  voice_note_url?: string;
  lat: number;
  lng: number;
}

interface CreateVerificationResponse {
  success: boolean;
  verification_id?: string;
  new_status?: 'pending' | 'verified';
  error?: 'self_verification' | 'already_verified' | 'not_found' | 'unknown';
  message?: string;
}

export async function createVerification(
  input: CreateVerificationInput
): Promise<CreateVerificationResponse> {
  const supabase = await createClient();

  try {
    // Step 1: Fetch issue with row lock
    const { data: issue, error: fetchError } = await supabase
      .from('issues')
      .select('id, user_id, session_id, verifications_count, status')
      .eq('id', input.issue_id)
      .single();

    if (fetchError || !issue) {
      return {
        success: false,
        error: 'not_found',
        message: 'Issue not found',
      };
    }

    // Step 2: Self-verification check (authenticated reports)
    if (issue.user_id && issue.user_id === input.verifier_id) {
      return {
        success: false,
        error: 'self_verification',
        message: 'You cannot verify your own report',
      };
    }

    // Step 3: Self-verification check (anonymous reports via session_id)
    if (
      !issue.user_id &&
      issue.session_id &&
      input.verifier_session_id &&
      issue.session_id === input.verifier_session_id
    ) {
      return {
        success: false,
        error: 'self_verification',
        message: 'You cannot verify your own report',
      };
    }

    // Step 4: Insert verification record
    const { data: verification, error: insertError } = await supabase
      .from('verifications')
      .insert({
        issue_id: input.issue_id,
        verifier_id: input.verifier_id,
        photo_url: input.photo_url,
        note: input.note || null,
        voice_note_url: input.voice_note_url || null,
        lat: input.lat,
        lng: input.lng,
      })
      .select('id')
      .single();

    if (insertError) {
      // Check for unique constraint violation (duplicate verification)
      if (insertError.code === '23505') {
        return {
          success: false,
          error: 'already_verified',
          message: 'You already verified this issue',
        };
      }

      console.error('Verification insert error:', insertError);
      return {
        success: false,
        error: 'unknown',
        message: 'Failed to create verification',
      };
    }

    // Step 5: Atomic increment + threshold check
    const newCount = issue.verifications_count + 1;
    let newStatus = issue.status;

    // If we hit 2 verifications and status is pending, promote to verified
    if (newCount >= 2 && issue.status === 'pending') {
      newStatus = 'verified';

      // Update issue status and count atomically
      const { error: updateError } = await supabase
        .from('issues')
        .update({
          verifications_count: newCount,
          status: newStatus,
          updated_at: new Date().toISOString(),
        })
        .eq('id', input.issue_id);

      if (updateError) {
        console.error('Issue update error:', updateError);
        // Don't fail - verification is already inserted
      }

      // Step 6: Increment reporter's verified_reports_count (if authenticated)
      if (issue.user_id) {
        await supabase.rpc('increment_verified_reports', {
          user_uuid: issue.user_id,
        });
      }
    } else {
      // Just increment count
      const { error: updateError } = await supabase
        .from('issues')
        .update({
          verifications_count: newCount,
          updated_at: new Date().toISOString(),
        })
        .eq('id', input.issue_id);

      if (updateError) {
        console.error('Issue count update error:', updateError);
      }
    }

    // Revalidate issue detail page
    revalidatePath(`/issues/${input.issue_id}`);

    return {
      success: true,
      verification_id: verification.id,
      new_status: newStatus,
    };
  } catch (error) {
    console.error('Unexpected error in createVerification:', error);
    return {
      success: false,
      error: 'unknown',
      message: 'An unexpected error occurred',
    };
  }
}
```

### Database Migrations

```sql
-- migrations/003_verifications_table.sql

-- Create verifications table
CREATE TABLE IF NOT EXISTS verifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  issue_id UUID NOT NULL REFERENCES issues(id) ON DELETE CASCADE,
  verifier_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
  photo_url TEXT NOT NULL,
  note TEXT,
  voice_note_url TEXT,
  lat DOUBLE PRECISION NOT NULL,
  lng DOUBLE PRECISION NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add unique constraint to prevent duplicate verifications
ALTER TABLE verifications
ADD CONSTRAINT unique_issue_verifier
UNIQUE(issue_id, verifier_id);

-- Add indexes for performance
CREATE INDEX idx_verifications_issue_id ON verifications(issue_id);
CREATE INDEX idx_verifications_verifier_id ON verifications(verifier_id);
CREATE INDEX idx_verifications_created_at ON verifications(created_at);

-- Add verifications_count column to issues table
ALTER TABLE issues
ADD COLUMN IF NOT EXISTS verifications_count INTEGER DEFAULT 0;

-- Add index on verifications_count for filtering
CREATE INDEX idx_issues_verifications_count ON issues(verifications_count);

-- Create PostgreSQL function to increment verified_reports_count
CREATE OR REPLACE FUNCTION increment_verified_reports(user_uuid UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE users
  SET verified_reports_count = COALESCE(verified_reports_count, 0) + 1
  WHERE id = user_uuid;
END;
$$ LANGUAGE plpgsql;

-- Add verified_reports_count to users table if not exists
ALTER TABLE users
ADD COLUMN IF NOT EXISTS verified_reports_count INTEGER DEFAULT 0;
```

### RLS Policies

```sql
-- Allow authenticated users to insert verifications
CREATE POLICY "authenticated_can_create_verifications" ON verifications
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = verifier_id);

-- Anyone can view verifications (for public issue pages)
CREATE POLICY "public_can_view_verifications" ON verifications
FOR SELECT USING (true);

-- Users can only update their own verifications (for Phase 2 edits)
CREATE POLICY "users_can_update_own_verifications" ON verifications
FOR UPDATE USING (auth.uid() = verifier_id);
```

---

## Tasks & Subtasks

### Task 1: Database Schema & Migrations

- [ ] Create migration: `003_verifications_table.sql`
- [ ] Create verifications table with all columns
- [ ] Add unique constraint: `UNIQUE(issue_id, verifier_id)`
- [ ] Add indexes for performance
- [ ] Add `verifications_count` column to issues table
- [ ] Create `increment_verified_reports()` PostgreSQL function
- [ ] Add `verified_reports_count` to users table
- [ ] Run migration: `npx supabase migration up`

### Task 2: RLS Policies

- [ ] Create policy: authenticated users can insert verifications
- [ ] Create policy: public can view verifications
- [ ] Create policy: users can update own verifications
- [ ] Test policies with different user roles
- [ ] Verify multi-org isolation

### Task 3: Create Server Action

- [ ] Create `/app/actions/createVerification.ts`
- [ ] Add input validation (Zod schema)
- [ ] Implement self-verification blocking logic
- [ ] Implement session_id self-verification check
- [ ] Insert verification record
- [ ] Atomic increment with threshold check
- [ ] Handle duplicate verification error
- [ ] Call increment_verified_reports() on threshold
- [ ] Add revalidatePath for cache invalidation

### Task 4: Race Condition Prevention

- [ ] Use single transaction for count increment
- [ ] Test concurrent verifications (2 users verify same issue)
- [ ] Verify threshold only triggers once
- [ ] Add database-level constraints if needed

### Task 5: Integration Tests

- [ ] Test: First verification increments count to 1
- [ ] Test: Second verification promotes to 'verified' status
- [ ] Test: Self-verification blocked (authenticated)
- [ ] Test: Self-verification blocked (anonymous via session_id)
- [ ] Test: Duplicate verification returns error
- [ ] Test: Concurrent verifications handled correctly
- [ ] Test: verified_reports_count increments on threshold

### Task 6: Error Handling & Logging

- [ ] Add error logging for all failure modes
- [ ] Return user-friendly error messages
- [ ] Log race condition occurrences
- [ ] Add monitoring for verification success rate

---

## Dependencies

- **Blocked by:**
  - Story 2.1.2 (Photo Upload) → IN PROGRESS
  - Story 2.1.3 (Context Notes) → IN PROGRESS
  - Database migration for verifications table
- **Blocks:**
  - Story 2.1.5 (Multi-Verifier Display)
  - Story 2.1.8 (Email Notifications)
  - Story 2.2.2 (Impact Metrics)
- **Related:**
  - Story 0.1 (Database schema foundation)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] createVerification Server Action functional
- [ ] Database migration applied successfully
- [ ] RLS policies created and tested
- [ ] Self-verification blocked (authenticated + anonymous)
- [ ] Duplicate verifications prevented
- [ ] 2-verification threshold triggers status change
- [ ] Race conditions handled (concurrent verifications)
- [ ] verified_reports_count increments correctly
- [ ] Integration tests written and passing (100% coverage)
- [ ] E2E tests verify complete flow
- [ ] Error messages user-friendly
- [ ] No console errors or warnings
- [ ] Code reviewed and approved
- [ ] Deployed to Vercel preview environment

---

## Notes

### Race Condition Handling

- **Problem:** Two users verify same issue simultaneously
- **Solution:** Atomic increment in single transaction
- **Test:** Playwright concurrent requests

### Session ID Integration

- **Why needed:** Anonymous reporters can't be blocked by user_id
- **Security:** Session IDs can be cleared, but 7-day expiry mitigates
- **Alternative:** IP-based blocking (less reliable)

### Threshold Logic

- **Why 2 verifications?** Balance between quality and speed
- **Phase 2:** Dynamic threshold based on issue severity
- **Status flow:** pending → verified → in_progress → resolved

### Design Decisions

- Verifications immutable after creation (can't edit/delete)
- One verification per user per issue (prevents spam)
- Verification always creates record (never fails silently)

### Performance Considerations

- Indexes on issue_id and verifier_id for fast lookups
- Denormalized verifications_count for query performance
- RLS policies use indexed columns only

### Accessibility

N/A (Server-side logic, no UI)

---

## Story Context XML

```xml
<story id="2.1.4" epic="2.1" points="6" sprint="2">
  <title>Create Verification Server Action with Self-Verification Block</title>
  <goal>Server-side verification creation with integrity checks and threshold logic</goal>

  <components>
    <create file="app/actions/createVerification.ts" reason="Server Action"/>
    <create file="supabase/migrations/003_verifications_table.sql" reason="Database schema"/>
  </components>

  <database>
    <table name="verifications">
      <column name="id" type="UUID" primary="true"/>
      <column name="issue_id" type="UUID" references="issues.id"/>
      <column name="verifier_id" type="UUID" references="users.id"/>
      <column name="photo_url" type="TEXT" required="true"/>
      <column name="note" type="TEXT" required="false"/>
      <column name="lat" type="DOUBLE PRECISION" required="true"/>
      <column name="lng" type="DOUBLE PRECISION" required="true"/>
      <constraint type="unique" columns="issue_id,verifier_id"/>
    </table>
  </database>

  <validation>
    <rule type="self-verification-auth" check="user_id !== verifier_id"/>
    <rule type="self-verification-anon" check="session_id !== verifier_session_id"/>
    <rule type="duplicate-check" constraint="UNIQUE(issue_id, verifier_id)"/>
    <rule type="threshold" count="2" action="promote-to-verified"/>
  </validation>

  <concurrency>
    <race-condition type="count-increment" solution="atomic-transaction"/>
    <testing scenario="concurrent-verifications" users="2"/>
  </concurrency>

  <testing>
    <integration scenarios="7" coverage="100%"/>
    <e2e scenario="verification-flow-end-to-end"/>
  </testing>
</story>
```
